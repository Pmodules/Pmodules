#!@BASH@ --noprofile

PATH='/bin:/usr/bin'
unset CDPATH	# unset CDPATH, otherwise 'cd' prints the directoy!
unset IFS	# use default IFS

shopt -s nullglob

# used for some output only
declare -r  CMD='modmanage'

declare     mydir=$(cd $(dirname "$0") && pwd)
declare     prefix=$(dirname "${mydir}")
declare     libdir="${prefix}/lib"
declare     libexecdir="${prefix}/libexec"
declare -r  bindir="${prefix}/bin"

source "${libdir}/libstd.bash"
source "${libdir}/libpmodules.bash"

_exit () {
	std::die 1 "\nInterrupted..."
}
trap '_exit' INT TERM

_err () {
	std::info "\nOops: got an error in function '${FUNCNAME[1]}', line ${BASH_LINENO[0]}"
	std::die 1 "Aborting ..."
}
trap '_err' ERR

path="/bin:/usr/bin:${bindir}"
[[ $(uname -s) == 'Darwin' ]] && path+=":${libexecdir}" 
std::def_cmds "${path}" 'chown' 'dirname' 'mkdir' 'rsync' 'rm' 'getopt' 'find' 'modulecmd'

unset mydir
unset prefix
unset libdir
unset libexecdir
# bindir we still need

declare PMODULES_VERSION='@PMODULES_VERSION@'

# In the dictionary Help we store the help text of each single command
# and for displaying the version.

# initialize help text of 'module --version'
Help['version']="
Pmodules @PMODULES_VERSION@ using Tcl Environment Modules @MODULES_VERSION@
Copyright GNU GPL v2
"

##############################################################################
#
# help [module|sub-command]
#
Subcommands[help]='help'
Options[help]='-o hHV\? -l version -l help'
Help[help]='
USAGE:
        modmanage [switches] subcommand [subcommand-args]...

SWITCHES:
        -h|-H|-?|--help         this usage info
        -V|--version            modules version & configuration options
        --debug                 enable debug output
	--dry-run               dry run


SUBCOMMANDS:
        + init [switches]       TARGET_DIR
        + install [switches]    module...
        + help                  [subcommand]
'

subcommand_help() {
        local -r subcommand='help'
	local -a args=()
	while (( $# > 0 )); do
		case $1 in
			-h | -\? | -H | --help )
				print_help "${subcommand}"
				;;
			-V | --version )
				print_help 'version'
				;;
			-- )
				shift 1
				args+=( "$@" )
				break
				;;
			* )
				args+=( "$1" )
				;;
		esac
		shift
	done
	for arg in "${args[@]}"; do
        	if [[ -n "${Help[${arg}]}" ]] ; then
                	print_help "${arg}"
                else
			std::die 1 "Unknown sub-command -- ${subcommand}"
		fi
	done
}

##############################################################################
#
# Derive the module installation path from the modulefile path.
# The passed modulefile must be absolute.
# 
# Arguments:
#	$1: absolute module file path
#
get_module_prefix() {
	"${modulecmd}" bash show "$1"  2>&1 \
		|awk '/_HOME |_PREFIX / {print $3; exit}'
}

##############################################################################
#
# Derive the relative module release file path
# from the relative module file path
#
# Arguments:
#	$1: relative module file path
#
get_releasefile_name() {
	echo "$(${dirname} "$1")/.release-$(basename "$1")"
}

##############################################################################
#
# Sync a module from one Pmodules environment to another:
# - sync module installation
# - sync modulefile
# - sync release file
#
# Arguments:
#	$1: relative modulefile path (something like: Tools/gnuplot/5.0.0)
#	$2: source prefix of Pmodule environment
#	$3: target prefix of Pmodule environment
#
sync_module() {
	local -r rel_modulefile="$1"
	local -r src_root="$2"
	local -r target_root="$3"

	local -r src_prefix=$( get_module_prefix "${src_root}/${rel_modulefile}" )
	local -r rel_prefix=${src_prefix#${src_root}}
	local -r target_prefix="${target_root}/${rel_prefix}"

	# install/update module
	if [[ ! -d "${target_prefix}" ]] || [[ "${force}" == 'yes' ]]; then
		${mkdir} -p "${target_prefix}" || exit $?
		${rsync} --links --perms --recursive --delete \
			 "${src_prefix}/" \
			 "${target_prefix}/" || exit $?
	fi

	# create modulefile direcrory and install modulefile
	local -r src_modulefile="${src_root}/${rel_modulefile}"
	local -r target_modulefile="${target_root}/${rel_modulefile}"
	
	${mkdir} -p "$(${dirname} "${target_modulefile}")" || exit $?

	if [[ -e "${src_modulefile}" ]]; then
	        ${rsync} --links --perms --recursive \
			 "${src_modulefile}" "${target_modulefile}" || exit $?
	fi

	# install release-file
	local -r rel_releasefile=$( get_releasefile_name "${rel_modulefile}" )
	local -r src_releasefile="${src_root}/${rel_releasefile}"
	local -r target_releasefile="${target_root}/${rel_releasefile}"

	if [[ -e "${src_releasefile}" ]]; then
	        ${rsync} --links --perms --recursive \
			  "${src_releasefile}" "${target_releasefile}" || exit $?
	fi

}

##############################################################################
#
# Sync the Pmodules configuration and templates
#
# Arguments:
#	$1: source prefix of Pmodule environment
#	$2: target prefix of Pmodule environment
#
sync_config() {
	src="$1/${PMODULES_CONFIG_DIR}/"
	dst="$2/${PMODULES_CONFIG_DIR}/"
	${rsync} --recursive --links --perms --delete \
		 "${src}" "${dst}" 2>/dev/null || return $?
	echo
}

##############################################################################
#
# Delete a module
#
# Arguments:
#	$1: relative modulefile path
#	$2: target prefix of Pmodule environment
#
delete_module() {
        echo "Not implemented yet!"
}

##############################################################################
#
# initialize a new module environment
#
Subcommands[init]='init'
Options[init]='-o h -l src: -l user: -l help -l version:'
Help[init]="
USAGE:
        modmanage init [switches] TARGET_DIR
                Initialize a new minimal Pmodule environment in TARGET_DIR.
                A user must be specified with '--user=<USER>' if the 
                programm is executed as root.


SWITCHES:
	--src <SRCDIR>
		Module environment we are going to sync from. If not
		specified, the module environment this script is in
		will be used.
	--user <USER>
		If this scripts runs with root privileges, a user name
		ore ID must be specified.
        --force
                re-initialise an already existing Pmodule environment.
"
 		
subcommand_init() {
	check_env() {
		[[ -n "${PMODULES_ROOT}" ]] &&
			[[ -d "${PMODULES_ROOT}" ]] &&
			[[ -n "${PMODULES_HOME}" ]] &&
			[[ -n "${PMODULES_VERSION}" ]] || \
				std::die 1 "
Error: the module environment you are going to use as source has not been
initialized properly!"

		[[ -d "${src_root}/${PMODULES_CONFIG_DIR}" ]] &&
			[[ -d "${src_root}/Tools/Pmodules/${PMODULES_VERSION}" ]] || \
				std::die 1 "
Error: the module environment '${src_root}' has not been initialized properly!"
	}
	
	local src_root=''
	local target_root=()
	local user=''
	while (($# > 0)); do
		case $1 in
			-h | -H | -\? | --help | -help )
				print_help "${subcommand}"
				;;
			--force | -f )
				force='yes'
				;;
			--src |Â --src=* )
				if [[ $1 == --src=* ]]; then
					src_root="${1#--*=}"
				else
					src_root="$2"
					shift
				fi
				;;
			--user | --user=* )
				if [[ $1 == --user=* ]]; then
					user="${1#--*=}"
				else
					user="$2"
					shift
				fi
				;;
			-- )
				:
				;;
			* )
				target_root="$1"
				;;
		esac
		shift
	done
	if [[ -z ${target_root} ]]; then
		std::die 1 "Error: no target directory specified!"
	fi
      
	# if source directory is not passed as argument, derive it from script name
	if [[ -z "${src_root}" ]]; then
	    src_root=$(cd "${bindir}/../../../.." && pwd) 
	fi
	[[ -d "${src_root}" ]] || \
		std::die 1 "Error: ${src_root}: source directory does not exist!"
	[[ -r "${src_root}/config/profile.bash" ]] || \
		std::die 1 "Error: ${src_root}: shell profile does not exist or is not readable!"
	source "${src_root}/config/profile.bash"

	local -i euid=$(id -u)
	if (( euid == 0 )); then
	        [[ -n "${user}" ]] || \
		    std::die 1 "Error: --user parameter is required!"
		id -u "${user}" > /dev/null 2>&1 || \
		    std::die 1 "Error: Unable to retrieve user id of user '${user}'"
	else
		[[ -z "${user}" ]] || \
		    std::die 1 "Error: --user option is only allowed if running as root!"
	fi

	check_env || \
		std::die 1 "Giving up..."

	echo "
Attempting to create a minimal module environment from the
environment at '${PMODULES_ROOT}'
"

	#.....................................................................
	# initialize new module environment in given directory
	#
	# Arguments:
	#	$1	target directory
	#
	init_pmodules_environment() {
		local -r src_root="${PMODULES_ROOT}"
		local -r target_root=$1
		local src=''
		local dst=''
		echo "Initializing target directory '${target_root}' ..."
		echo
		if [[ -d "${target_root}" ]]  && [[ ${force} == no ]]; then
			echo "Warning: ${target_root} already exists."
			std::get_YN_answer "Do you really want to re-run the initialization? (y/N) " || \
			        std::die 1 "Abort ..."
		fi
		force='yes'
		echo "Creating target directory '${target_root}'..."
		${mkdir} -p "${target_root}" || \
		        std::die 1 "Error: make directory failed!"
		echo

		echo "Syncing configuration ..."
		sync_config "${src_root}" \
		            "${target_root}" || \
		        std::die 1 "Error: configuration synchronization failed!"

		echo "Syncing Pmodules ${PMODULES_VERSION} from '${src_root}' to '${target_root}'..."
		sync_module "Tools/${PMODULES_MODULEFILES_DIR}/Pmodules/${PMODULES_VERSION}" \
			    "${src_root}" \
			    "${target_root}" || \
		        std::die 1 "Error: sync Pmodules failed!"
		${mkdir} -p "${target_root}/Tools/${PMODULES_MODULEFILES_DIR}"
		echo

		if [[ -n "${user}" ]]; then
	                echo "Changing user of new module environment to '${user}'..."
                        ${chown} -R "${user}" "${target_root}" || \
			        std::die 1 "Error: changing owner failed!"
                        echo
		fi
		echo "New minimal module environment created at '${target_root}'."
		echo "To use this environment, execute"
		echo "   sudo ln -fs ${target_root} /opt/psi"
		echo "   source /opt/psi/${PMODULES_CONFIG_DIR}/profile.bash"
	}

	umask 022
	init_pmodules_environment "${target_root}"
}


##############################################################################
#
# sub-command 'install'
# 
# Arguments:
Subcommands[install]='install'
Options[install]='-o hf -l force -l with: -l help -l src: -l target:'
Help[install]='
USAGE:
        modmanage install [switches] <module>...
                Install modules

SWITCHES:
	--force] | -f
		Install module even it already exists

	--src <src>
		Install from module environment in <src>

	--with <module>
		Install module(s) in this sub-group only

	<module_pattern>
		Install modules matching given pattern
'

subcommand_install() {
	local -r    subcommand='install'
	local	    opts=''
	local -a    with=()
	local -a    module_pattern=()
	local	    src_root="${PMODULES_INSTALL_SOURCE}"
	local       target_root="${PMODULES_ROOT}"
	local	    modulefile=''
	local -A    modules_to_install
	local -A    dependencies_to_install
	local -A    map_to_group
	local -a    modulepath=()

	#......................................................................
	#
	set_initial_modulepath() {
		local group
		for  group in "${!GroupDepths[@]}"; do
			(( ${GroupDepths[${group}]} == 0 )) || continue
			modulepath+=( "${src_root}/${group}/${PMODULES_MODULEFILES_DIR}" )
		done
	}

	#......................................................................
	#
	create_groupheads_map() {
		:
	}
	
	#......................................................................
	#
	# Resolve dependencies to given module
	#
	# Arguments:
	#   $1	absolute module file name
	#
	# Notes:
	#   Following variables from the enclosing function are used:
	#	modulepath (might be changed)
	#	map_to_group (read-only)
	#
	resolve_dependencies_of_module () {
	 	local -r modulefile="$1"

		local -- prefix=$(get_module_prefix "${modulefile}")
		local -a rdeps=()
		local    rdeps_file="${prefix}/.dependencies"
		local -a ideps=()
		local    ideps_file="${prefix}/.install_dependencies"
		
		if [[ -r "${rdeps_file}" ]]; then
			mapfile -t rdeps < <(grep -v '^ *#' "${rdeps_file}" )
		fi
		if [[ -r "${ideps_file}" ]]; then
			mapfile -t ideps < <(grep -v '^ *#' "${ideps_file}" )
		fi

		# loop over all dependecies
		local dep
		for dep in "${rdeps[@]}" "${ideps}"; do
			[[ -n ${dep} ]] || continue
			# search module with current modulepath
			local modulename=$(${find} "${modulepath[@]}" -path "*/${dep}" \
						   -print -quit 2>/dev/null)
			[[ -n ${modulename} ]] || \
				std::die 3 "Oops: required module '${dep}' not found!"
			
			dependencies_to_install[${modulename/${src_root}\/}]='.'
			_resolve_dependencies "${modulename}"
			if [[ -n ${map_to_group[${dep}]} ]]; then
				# append hierarchical group to modulepath
				local path="${src_root}/${map_to_group[${dep}]}/"
				path+="${PMODULES_MODULEFILES_DIR}/"
				path+="${modulename/*\/${PMODULES_MODULEFILES_DIR}\/}"
				modulepath+=( "${path}" )
			fi
		done
	}

	#......................................................................
	#
	# Print list of modules which will be installed and ask user wheter
	# he wants to continue or abort.
	#
	# Arguments:
	#   none
	#
	# Notes:
	#   Following variables from the enclosing function are used:
	#	target_root (read-only)
	#	modules_to_install (read-only)
	#	dependencies_to_install (read-only)
	#
	
	print_modules_to_install() {
		local modulefile
		local parts
		std::info "The following modules will be installed/updated:"
		for modulefile in "${!modules_to_install[@]}"; do
			std::split_fname parts "${modulefile}"
			std::info "    ${parts[-2]}/${parts[-1]}"
		done 2>&1 | sort
		if (( ${#dependencies_to_install[@]} > 0 )); then
			std::info "\nThe following dependencies will be installed/updated:"
			for modulefile in "${!dependencies_to_install[@]}"; do
				std::split_fname parts "${modulefile}"
				std::info "    ${parts[-2]}/${parts[-1]}"
			done 2>&1 | sort
		fi
		std::info ""
		std::get_YN_answer "Do you want to continue? [n] " || \
			std::die 1 "Aborting..."
		std::info ""
	}
	
	while (($# > 0)); do
		case $1 in
			-h | -H | -\? | --help | -help )
				print_help "${subcommand}"
				;;
			--force | -f )
				force='yes'
				;;
			--src | --src=*)
                                if [[ $1 == --src=* ]]; then
                                        src_root="${1#--*=}"
				else
                                        src_root="$2"
                                        shift
                                fi
				;;
			--target | --target=*)
                                if [[ $1 == --target=* ]]; then
                                        target_root="${1#--*=}"
				else
                                        target_root="$2"
                                        shift
                                fi
				;;
			--with | --with=* )
                                if [[ "$1" == --with ]]; then
                                        with+=( "$2" )
                                        shift
                                else
                                        with+=( "${1/--with=}" )
                                fi
				;;
			-- )
				:
				;;
			* )
				module_pattern+=( "$1" )
				;;
		esac
		shift
	done

	[[ -n ${src_root} ]] \
		|| std::die 3 "Oops: no installation source given."
	[[ -d ${src_root} ]] \
		|| std::die 3 "Oops: '${src_root}' is not a valid installation source."

	scan_groups "${src_root}"
	set_initial_modulepath

	#
	# create a mapping from module name to their group.
	# Examples:
	#     gcc/5.2.0 -> Compiler
	#     openmpi/1.8.4 -> MPI
	local    fname=''
	local -i n
	local -a parts
	while read fname; do
		std::split_fname parts n "${fname}"
		group="${parts[0]}"
		# We are only interested in groups adding something to
		# the modulepath.
		if (( n >= 6 )); then
			map_to_group[${parts[-4]}/${parts[-3]}]=${group}
		fi
	done < <({ cd "${src_root}" && \
				 ${find} */"${PMODULES_MODULEFILES_DIR}" \
				      \( -type l -o -type f \) \! -name ".*"; } 2>/dev/null )

	# search for to be installed modules and their dependencies
	while read modulefile; do
		modules_to_install["${modulefile/${src_root}}"]+='.'
		resolve_dependencies_of_module "${modulefile}"
	done < <("${modulecmd}" bash search \
				 "${module_pattern[@]}" \
				 "${with[@]/#/--with=}" \
				 -a --glob \
				 --no-header --print-modulefiles \
				 --src="${src_root}"  2>&1 1>/dev/null)
	(( ${#modules_to_install[@]} == 0 )) && \
		std::die 0 "No matching modules found ..."
	print_modules_to_install

	# install/update ...
	for modulefile in "${!modules_to_install[@]}" "${!dependencies_to_install[@]}"; do
		std::split_fname parts "${modulefile}"
		std::info "    ${parts[-2]}/${parts[-1]}"
		sync_module "${modulefile}" "${src_root}" "${target_root}"
	done
	std::info "\nDone!\n"
} # subcommand_install

###############################################################################
#
# delete specified module(s)
#
subcommand_delete() {
	:
}

###############################################################################
#
# remove modules which have been removed in our source
#
subcommand_cleanup() {
	:
}

declare force='no'
declare subcommand=''
declare -a opts=()
while (($# > 0)); do
	case $1 in
		-h | -H | -\? | --help | -help )
			print_help 'help'
			;;
		-V | --version )
			print_help 'version'
			;;
		--debug )
			set -x
			;;
		--dry-run )
			chown="echo ${chown}"
			mkdir="echo ${mkdir}"
			rsync="echo ${rsync}"
			;;
		-* )
			opts+=( "$1" )
			;;
		* )
			subcommand="$1"
			shift
			break
			;;
	esac
	shift || :
done

if [[ -z "${subcommand}" ]]; then
	std::die 1 "${CMD}: no sub-command specified.\n"
	print_help 'help'
fi

if [[ -z "${Subcommands[${subcommand}]}" ]]; then
	std::die 1 "${CMD}: unknown sub-command -- ${subcommand}\n"
fi

if [[ "${subcommand}" != "init" ]] && [[ -z "${PMODULES_ROOT}" ]]; then
        std::die 1 "Error: No current module environment configured!"
fi

tmp=$("${getopt}" ${Options[${subcommand}]} -- "${opts[@]}" "$@" ) \
        || print_help "${subcommand}"
eval args=( "$tmp" )
unset tmp
subcommand_${Subcommands[$subcommand]} "${args[@]}"

# Local Variables:
# mode: sh
# sh-basic-offset: 8
# tab-width: 8
# End:
