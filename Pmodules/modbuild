#!/bin/bash

#.............................................................................
# get absolute path of script
declare	    mydir=$(dirname "$0")
declare -r  mydir=$(cd ${mydir} && pwd -P)

PATH="/usr/bin:/bin:/usr/sbin:/sbin"

# add pathes where files we have to source are installed
PATH+=":${mydir}:${mydir}/../lib:${mydir}/../config"

source libstd.bash    || { echo "Oops: library '$_' cannot be loaded!" 1>&2; exit 3; }

#.............................................................................
# constants
declare	   fname_build_config='modbuild.conf'

#.............................................................................
# defaults for arguments/options

# number of parallel make jobs
declare -i  JOBS=3

declare force_rebuild='no'
declare dry_run='no'
declare enable_cleanup_build='yes'
declare enable_cleanup_src='no'
declare build_target='all'
declare bootstrap='no'
declare SYSTEM="$(uname -s)"
declare opt_update_modulefiles='no'

# array collecting all modules specified on the command line via '--with=module'
declare -a with_modules=()

# save arguments, we might need them later again for building dependencies
declare -r ARGS="$@"

##############################################################################
#
usage() {
	std::error "
USAGE:
        $0 [options..] [build_script] version

MANDATORY ARGUMENTS:

version
        Variant of module to build.

SELECT VARIANT TO BUILD:

--system
        Specify the system for selecting a variants. Defaults to the
	output of 'uname -s'.

--with=P/V
        Select variant to compile. Use multiple '--with' arguments
	to make the selected variant unique.

BUILD-STEPS OPTIONS:

--prep
	Prepare sources: unpack sources and apply patches only.

--configure
	Prepare and configure sources.

--compile
	Prepare, configure and compile everything.

--install
	Prepare, configure and compile everything. Finally run install
	step. Do not cleanup build and source directory.

--all
	Run throu all steps including cleanup.

--update-modulefiles
	Only install the modulefile and set the release.

MISCELLANEOUS OPTIONS:

-? | -h | --help
        Print usage

-v | --verbose )
        Verbose output

-j N | --jobs=N
        Run N parallel make jobs

-f | --force-rebuild
        Force rebuild of module.

--dry-run
	Dry run.

--all-variants
        Build build all variants

--disable-cleanup-build
--enable-cleanup-build
	Cleanup files in the build directory. Default is to remove.
      	all files in the build-directory.

--disable-cleanup-src
--enable-cleanup-src
	Cleanup files in the source directory. Default is to
	remove all files in the source directory.

--disable-cleanup
--enable-cleanup
	Cleanup all files in temporyry directory. Default is to
	remove all files created during building.

--distdir
	Directory wwhere to store and lookup downloaded files.

--tmpdir
        Directory used for building a module.

"
	exit 1
}

##############################################################################
#

declare -a versions=()
declare opt_all_variants='no'
parse_args() {
	while (( $# > 0 )); do
		case $1 in
		-j )
			JOBS=$2
			shift
			;;
		--jobs=[0-9]* )
			JOBS=${1/--jobs=}
			;;
		-v | --verbose )
			trap 'echo "$BASH_COMMAND"' DEBUG
			;;
		--debug )
			set -x
			;;
		-f | --force-rebuild )
			force_rebuild='yes'
			;;
		-\? | -h | --help )
			usage
			;;
		--dry-run )
			dry_run='yes'
			;;
                --all-variants )
                        opt_all_variants='yes'
                        ;;
		--config )
			fname_build_config="$2"
			shift 1
			;;
		--config=* )
			fname_build_config="${1#*=}"
			;;
		--disable-cleanup )
			enable_cleanup_build='no'
			enable_cleanup_src='no'
			;;
		--enable-cleanup-build )
			enable_cleanup_build='yes'
			;;
		--disable-cleanup-build )
			enable_cleanup_build='no'
			;;
		--enable-cleanup-src )
			enable_cleanup_src='yes'
			;;
		--disable-cleanup-src )
			enable_cleanup_src='no'
			;;
		--distdir )
			PMODULES_DISTFILESDIR=$2
			shift
			;;
		--distdir=* )
			PMODULES_DISTFILESDIR=${1/--distdir=}
			;;
		--tmpdir )
			TEMP_DIR=$2
			shift
			;;
		--tmpdir=* )
			TEMP_DIR=${1/--tmpdir=}
			;;
		--system )
			SYSTEM=".$2"
			shift
			;;
		--system=* )
			SYSTEM=".${1/*=}"
			;;
		--with )
			with_modules+=( "$2" )
			shift
			;;
		--with=*/* )
			m="${1/--with=}"
			with_modules+=( ${m} )
			;;
		--prep | --configure | --compile | --install | --all )
			build_target=${1:2}
			;;
		--bootstrap )
			bootstrap='yes'
			;;
		--update-modulefiles )
			opt_update_modulefiles='yes'
			;;
		-* )
			std::die 1 "Invalid option -- '$1'"
			;;
		[0-9]* )
			versions+=( "$1" )
			;;
		'')	
			:
			;;
		* )
			[[ -z "${BUILD_SCRIPT}" ]] || \
				std::die 1 "%s "\
					 "Build script already set to" \
					 "'${BUILD_SCRIPT}' -- '$1'"
		        BUILD_SCRIPT=$(std::get_abspath "$1")
			test -r ${BUILD_SCRIPT} || \
				std::die 1 "%s " \
					 "Build script does not exist" \
					 "or is not readable -- '$_'"
			BUILDBLOCK_DIR=$(dirname "${BUILD_SCRIPT}")
			;;
		esac
		shift
	done	
	[[ -n ${BUILD_SCRIPT} ]] || std::die 1 "No build-block specified!"
	(( ${#versions[@]} > 0)) || std::die 1 "Module version not specified!"
}

source libpbuild.bash || std::die 3 "Oops: library '$_' cannot be loaded!"

find_variants_files(){
	local files=( $(ls -1 "${BUILDBLOCK_DIR}"/*/variants.${SYSTEM} 2> /dev/null) )
        local f
	for f in "${BUILDBLOCK_DIR}"/*/variants; do
		if [[ ! -e "${f}.${SYSTEM}" ]]; then
			files+=( "$f" )
		fi
	done
	std::upvar "$1" "${files[@]}"
}

build_modules() {
        local name="$1"
        local version="$2"
        local exact_match='no'
        if [[ "${version:0:1}" == "=" ]]; then
                exact_match='yes'
                version="${version:1}"
        fi
        shift 2
        local with_modules=( $* )
        local files
        find_variants_files files
        local m
	local pattern="/^${name}\/${version}[[:blank:]]/"
	for m in "${with_modules[@]}"; do 
		pattern+=" && /${m//\//\\/}/"
	done
        local variants=()
        local variants_files=()
        local lines=()
        for f in "${files[@]}"; do
                mapfile -t lines < <(awk "${pattern}" "${f}")
                variants+=( "${lines[@]}" )
                local i
                for ((i=0; i<${#lines[@]}; i++)); do
                        variants_files+=( "$f" )
                done
                # here we should add a check, whether the version of the
                # found variants are in the right variants files. Example:
                # a variant for hdf5/1.10.4 is not allowed in a variants file
                # for version 1.8
        done
        if (( ${#variants[@]} == 0 )); then
		std::info "%s " \
			 "${name}/${version}:" \
			 "no suitable variant found!"
                std::die 10 "Aborting..."
        elif (( ${#variants[@]} > 1 )) && [[ ${exact_match} == 'yes' ]]; then
		std::info "%s " \
			 "Multiple variants found:"
                for variant in "${variants[@]}"; do
                        std::info "${variant}"
                done
                std::die 10 "Aborting..."
        fi
        local -i i=0
        local -i num_variants=${#variants[@]}
        for ((i = 0; i < num_variants; i++)); do
                local tokens=( ${variants[i]} )
                local name="${tokens[0]%/*}"
                version="${tokens[0]#*/}"
                release="${tokens[1]}"
                with_modules=( "${tokens[@]:2}" )
                pbuild.build_module \
                        "${name}" "${version}" \
                        "${release}" "${with_modules[@]}"
        done
}

#.............................................................................
# main
parse_args "$@"

declare -r BUILD_SCRIPT
declare -r BUILDBLOCK_DIR

# source Pmodule environment configuration
test -d ":${BUILDBLOCK_DIR}/../../${PMODULES_CONFIG_DIR}" && PATH+=":$_"
test -d "${PMODULES_ROOT}/${PMODULES_CONFIG_DIR}" && PATH+=":$_"
source "${fname_build_config}" || std::die 3 "Cannot source build configuration file."

: ${TEMP_DIR:="${PMODULES_TMPDIR:-/var/tmp/${USER}}"}
declare -rx  TEMP_DIR
: ${PMODULES_DISTFILESDIR:="${BUILD_BASEDIR}/Downloads"}
declare -xr  PMODULES_DISTFILESDIR
mkdir -p "${PMODULES_DISTFILESDIR}"

MODULECMD="${PMODULES_HOME}/bin/modulecmd"
[[ -x ${MODULECMD} ]] || \
	std::die 2 "No such file or executable -- '${MODULECMD}'"

IFS=/ read -r -a fname <<< "${BUILD_SCRIPT:1}"
module_name=${fname[${#fname[@]}-2]}

#
# are we bootstrapping? If yes, everything is a bit simpler...
#
if [[ "${bootstrap}" == 'yes' ]]; then
	MODULECMD='/bin/true'
        #......................................................................

	C_INCLUDE_PATH="${PREFIX}/include"
	CPLUS_INCLUDE_PATH="${PREFIX}/include"
	CPP_INCLUDE_PATH="${PREFIX}/include"
	LIBRARY_PATH="${PREFIX}/lib"
	LD_LIBRARY_PATH="${PREFIX}/lib"
	DYLD_LIBRARY_PATH="${PREFIX}/lib"

	PATH+=":${PREFIX}/bin"
	PATH+=":${PREFIX}/sbin"

	pbuild.build_module "${module_name}"  "{versions[0]" 'stable'
        exit $?
fi

eval $( "${MODULECMD}" bash use unstable )
eval $( "${MODULECMD}" bash use deprecated )

# if option '--all-variants' is set, we loop over all variants matching the given
# versions
for version in "${versions[@]}"; do
        if [[ "${opt_all_variants}" == "no" ]]; then
                version="=${version}"
        fi
        build_modules "${module_name}" "${version}" "${with_modules[@]}"
done

# Local Variables:
# mode: sh
# sh-basic-offset: 8
# tab-width: 8
# End:
