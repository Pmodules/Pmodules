#!/bin/bash

#.............................................................................
# get absolute path of script
declare	    mydir=$(dirname "$0")
declare -r  mydir=$(cd ${mydir} && pwd -P)
declare -r  prog=$(basename "$0")

# The libs are found via PATH
PATH="/usr/bin:/bin:/usr/sbin:/sbin:${mydir}:${mydir}/../lib"
source libstd.bash    || { echo "Oops: library '$_' cannot be loaded!" 1>&2; exit 3; }
source libpbuild.bash || std::die 3 "Oops: library '$_' cannot be loaded!"

#.............................................................................
# constants
declare -r  PMODULES_BUILD_CONFIG='modbuild.conf'

##############################################################################
#
usage() {
	std::error "
Usage: $0 [OPTIONS..] [BUILD_SCRIPT] [VERSION]

VERSION
        Version of module to compile.

-? | -h | --help
        Print usage

-v | --verbose )
        Verbose output

-j N | --jobs=N
        Run N parallel make jobs

-f | --force-rebuild
        Force rebuild of module.

--dry-run
	Dry run.

--enable-cleanup-build
	Cleanup files in the build directory (default).

--enable-cleanup-src
	Cleanup files in the source directory.

--disable-cleanup
	Keep files in build and source directory

--disable-cleanup-build
	Keep files in build directory.

--disable-cleanup-src
	Keep files in source directory (default).

--variants-file
        Specify which variants file to use

--with=P/V
        Preload module P with version V. To preload multiple modules,
        use this option per module. Order may matter!

--release=stable|unstable|deprecated

--prep
	Unpack sources only.

--configure
	Unpack sources and configure build.

--compile
	Unpack sources, configure build and compile software

--install
	Unpack sources, configure build, compile software and install.

--all
	Do everything, this step includes cleanup files and setting 
	the symbolic link to the modulefile.
"
	exit 1
}

##############################################################################
#
parse_args() {
	while (( $# > 0 )); do
		case $1 in
		-j )
			JOBS=$2
			shift
			;;
		--jobs=[0-9]* )
			JOBS=${1/--jobs=}
			;;
		-v | --verbose )
			trap 'echo "$BASH_COMMAND"' DEBUG
			;;
		--debug )
			set -x
			;;
		-f | --force-rebuild )
			force_rebuild='yes'
			;;
		-\? | -h | --help )
			usage
			;;
		--dry-run )
			dry_run='yes'
			;;
		--disable-cleanup )
			enable_cleanup_build='no'
			enable_cleanup_src='no'
			;;
		--enable-cleanup-build )
			enable_cleanup_build='yes'
			;;
		--disable-cleanup-build )
			enable_cleanup_build='no'
			;;
		--enable-cleanup-src )
			enable_cleanup_src='yes'
			;;
		--disable-cleanup-src )
			enable_cleanup_src='no'
			;;
		--distdir )
			PMODULES_DISTFILESDIR=$2
			shift
			;;
		--distdir=* )
			PMODULES_DISTFILESDIR=${1/--distdir=}
			;;
		--tmpdir )
			TEMP_DIR=$2
			shift
			;;
		--tmpdir=* )
			TEMP_DIR=${1/--tmpdir=}
			;;
		--variants-file )
			variants_file="$2"
			shift
			;;
		--variants-file=* )
			variants_file="${1/--variants-file=}"
			test -r "${variants_file}" || std::die 1 \
				"${prog}: variants file does not exist or is not readable -- '$_'"
			;;
		--with )
			with_modules+=( "$2" )
			shift
			;;
		--with=*/* )
			m="${1/--with=}"
			with_modules+=( ${m} )
			;;
		--prep | --configure | --compile | --install | --all )
			build_target=${1:2}
			;;
		--bootstrap )
			bootstrap='yes'
			;;
		--install-modulefile )
			opt_install_modulefile='yes'
			;;
		-* )
			std::die 1 "${prog}: invalid option -- '$1'"
			;;
		[0-9]* )
			[[ -z "$V" ]] || std::die 1 "${prog}: version already set -- '$1'"
			V=$1
			;;
		* )
			[[ -z "${BUILD_SCRIPT}" ]] || \
				std::die 1 "${prog}: build script already set -- '$1'"
		        BUILD_SCRIPT=$(std::get_abspath "$1")
			test -r ${BUILD_SCRIPT} || \
				std::die 1 "${prog}: build script does not exist or is not readable -- '$_'"
			BUILDBLOCK_DIR=$(dirname "${BUILD_SCRIPT}")
			;;
		esac
		shift
	done	
	[[ -n ${BUILD_SCRIPT} ]] || std::die 1 "${prog}: No build-block specified!"
	[[ -n ${V} ]]            || std::die 1 "${prog} Module version not specified!"
}

set_module_name_and_version_strings() {
	P=$(basename $(dirname "$1"))
	V_MAJOR=''
	V_MINOR=''
	V_PATCHLVL=''

	V_PKG="${V%%-*}"
	V_RELEASE="${V#*-}"
	local tmp="${V_PKG}"

	case "${tmp}" in
		*.*.* )
			V_MAJOR="${tmp%%.*}"
			tmp="${tmp#*.}"
			V_MINOR="${tmp%%.*}"
			V_PATCHLVL="${tmp#*.}"
			;;
		*.* )
			V_MAJOR="${tmp%.*}"
			V_MINOR="${tmp#*.}"
			;;
		* )
			V_MAJOR="${tmp}"
			;;
	esac
}

#......................................................................
# setup environment for bootstrapping
#
setup_env_for_bootstrapping() {
	ModuleGroup='Tools'
	ModuleName="Pmodules/${PMODULES_VERSION}"
	# set PREFIX of module
	PREFIX="${PMODULES_ROOT}/${ModuleGroup}/${ModuleName}"
	
	ModuleRelease='unstable'

	C_INCLUDE_PATH="${PREFIX}/include"
	CPLUS_INCLUDE_PATH="${PREFIX}/include"
	CPP_INCLUDE_PATH="${PREFIX}/include"
	LIBRARY_PATH="${PREFIX}/lib"
	LD_LIBRARY_PATH="${PREFIX}/lib"
	DYLD_LIBRARY_PATH="${PREFIX}/lib"

	PATH+=":${PREFIX}/bin"
	PATH+=":${PREFIX}/sbin"
}

#......................................................................
#
# Search for variants file to use
#
# Arguments:
#   none
#
# Used global variables:
#   OS
#   BUILDBLOCK_DIR
#   variants_file [out]
#
search_variants_file() {
	local -a eligible_variants_files=()
	eligible_variants_files+=( "${V%.*.*}/variants.${OS}" )
	eligible_variants_files+=( "${V%.*.*}/variants" )
	eligible_variants_files+=( "${V%.*}/variants.${OS}" )
	eligible_variants_files+=( "${V%.*}/variants" )
	eligible_variants_files+=( "${V}/variants.${OS}" )
	eligible_variants_files+=( "${V}/variants" )
	eligible_variants_files+=( "files/variants.${OS}" )
	eligible_variants_files+=( "files/variants" )

	for variants_file in "${eligible_variants_files[@]}"; do
		if [[ -e "${BUILDBLOCK_DIR}/${variants_file}" ]]; then
			variants_file="${BUILDBLOCK_DIR}/${variants_file}"
		    	return 0
	    	fi
	done
	variants_file=''
	return 1
}

#.............................................................................
# defaults for arguments/options

# number of parallel make jobs
declare -i  JOBS=3

declare force_rebuild='no'
declare dry_run='no'
declare enable_cleanup_build='yes'
declare enable_cleanup_src='no'
declare build_target='all'
declare bootstrap='no'
declare variants_file=''
declare opt_install_modulefile=''

# array collecting all modules specified on the command line via '--with=module'
declare -a with_modules=()

# save arguments, we might need them later again for building dependencies
declare -r ARGS="$@"

#.............................................................................
# main
parse_args "$@"
declare -r BUILD_SCRIPT
declare -r BUILDBLOCK_DIR

set_module_name_and_version_strings "${BUILD_SCRIPT}" "$V"

# source Pmodule environment configuration
PATH+="${BUILDBLOCK_DIR}/../../config/${PMODULES_BUILD_CONFIG}"
PATH+=":${PMODULES_ROOT}/${PMODULES_CONFIG_DIR}"
source "${PMODULES_BUILD_CONFIG}" || std::die 3 "${prog}: Cannot source build configuration file."

: ${TEMP_DIR:="${PMODULES_TMPDIR:-/var/tmp/${USER}}"}
declare -rx  TEMP_DIR
: ${PMODULES_DISTFILESDIR:="${BUILD_BASEDIR}/Downloads"}
declare -xr  PMODULES_DISTFILESDIR
mkdir -p "${PMODULES_DISTFILESDIR}"

SRC_DIR="${TEMP_DIR}/$P-$V/src"
BUILD_DIR="${TEMP_DIR}/$P-$V/build"

if [[ ${bootstrap} == no ]]; then
	if [[ -z "${variants_file}" ]]; then
		search_variants_file || \
			std::die 2 "${prog}: No usable variants file found!"
	fi

        # initialize module environment
	MODULECMD="${PMODULES_HOME}/bin/modulecmd"
	[[ -x ${MODULECMD} ]] || \
			std::die 2 "${prog}: no such file or executable -- '${MODULECMD}'"

	eval $( "${MODULECMD}" bash purge )
	eval $( "${MODULECMD}" bash use unstable )
	eval $( "${MODULECMD}" bash use deprecated )

	# :FIXME: this is a hack!!!
	eval $( "${MODULECMD}" bash use Libraries )
else
	setup_env_for_bootstrapping
fi

#
# run build
#
source "${BUILD_SCRIPT}"

std::info "${P}/${V}: Done ..."

# Local Variables:
# mode: sh
# sh-basic-offset: 8
# tab-width: 8
# End:
