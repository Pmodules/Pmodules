#!@PMODULES_HOME@/bin/bash --noprofile
#

#set -o nounset
# we have to unset CDPATH, otherwise 'cd' prints the directoy!
unset CDPATH

# used for some output only
declare -r  CMD='module'

declare -r  mydir=$(cd $(dirname "$0") && pwd)
declare     prefix=$(dirname "${mydir}")
declare -r  bindir="${prefix}/bin"
declare -r  libdir="${prefix}/lib"
declare -r  libexecdir="${prefix}/libexec"

source "${libdir}/libstd.bash"
source "${libdir}/libpmodules.bash"

PATH="${bindir}:${PATH}"

declare -r  version='@PMODULES_VERSION@'

if [[ ${PMODULES_PURETCL} == yes ]]; then
	declare -r  modulecmd="${libexecdir}/modulecmd.tcl"
else
	declare -r  modulecmd="${libexecdir}/modulecmd.bin"
fi

declare -rx TCL_LIBRARY="${libdir}/tcl8.6"

# required for pre 0.99.3 modulefiles
declare -rx PSI_LIBMODULES="${TCL_LIBRARY}/libmodules.tcl"

declare verbosity_lvl=${PMODULES_VERBOSITY:-'verbose'}

shopt -s nullglob

declare -a Groups='()'
declare -A GroupDepths='()'
declare current_modulefile=''
declare g_shell=''

pbuild::export_env() {
	local -r shell=$1
	shift
	case ${shell} in
	bash )
		local -r fmt="export %s=\"%s\"; "
		;;
	tcsh )
		local -r fmt="setenv %s \"%s\""
		;;
	* )
		std::die 1 "${shell} is an unsupported shell"
		;;
	esac
	

	while (( $# > 0 )); do
		printf "${fmt}" "$1" "${!1}"
		shift
	done
}

pbuild::save_env() {
	local -r shell=$1
	shift
	local s=''
	local tmp
	while (( $# > 0 )); do
		tmp="$( typeset -p $1 2> /dev/null)"
		[[ -n "${tmp}" ]] && s+="${tmp};"
		shift
	done
	declare -g PMODULES_ENV=$( "${PMODULES_HOME}/bin/base64" --wrap=0 <<< "$s" )
	pbuild::export_env ${shell} PMODULES_ENV
}

trap 'pbuild::save_env ${g_shell} Groups GroupDepths UsedReleases PMODULES_DEFAULT_GROUPS PMODULES_DEFINED_RELEASES PMODULES_DEFAULT_RELEASES PMODULES_USED_GROUPS' EXIT

print_version() {
	echo "
Pmodules ${version} using Tcl Environment Modules @MODULES_VERSION@
Copyright GNU GPL v2
" 1>&2
}

usage() {
	print_version
	echo "
USAGE:
        module [ switches ] [ subcommand ] [subcommand-args ]

SWITCHES:
        -h|-H|-?|--help         this usage info
        -V|--version            modules version & configuration options

SUBCOMMANDS:
        + add|load [switches]   modulefile [modulefile ...]
        + rm|unload             modulefile [modulefile ...]
        + switch|swap           [modulefile1] modulefile2
        + display|show          modulefile [modulefile ...]
        + avail [switches]      [modulefile [modulefile ...]]
        + search [switches]     [args]
        + use [switches]        [dir|group|release ...]
        + unuse                 dir|group|release [dir|group|release ...]
        + refresh
        + purge
        + list [switches]
        + clear
        + help                  [modulefile|subcommand]
        + whatis                [modulefile [modulefile ...]]
        + apropos|keyword       string
        + initadd               modulefile [modulefile ...]
        + initprepend           modulefile [modulefile ...]
        + initrm                modulefile [modulefile ...]
        + initswitch            modulefile1 modulefile2
        + initlist
        + initclear
" 1>&2
	std::die 1
}

subcommand_help_add() {
	echo "
USAGE:
        module add     modulefile...
        module load    modulefile...
                Load modulefile(s) into the shell environment. Loading a
		'group-head' will extend the MODULEPATH. E.g.: loading a 
		compiler makes additional modules like openmpi and libraries
		compiled with this compiler available.
" 1>&2
	std::die 1
}

subcommand_help_load() {
	subcommand_help_add
}

subcommand_help_rm() {
	echo "
USAGE:
        module rm      modulefile...
        moudle unload  modulefile...
                Remove modulefile(s) from the shell environment. Removing
		a 'group-head' will also unload all modules belonging to
		this group.
" 1>&2
	std::die 1
}

subcommand_help_unload() {
	subcommand_help_rm
}

subcommand_help_switch() {
	echo "
USAGE:
        module switch  [modulefile1] modulefile2
        module swap    [modulefile1] modulefile2
		Switch loaded modulefile1 with modulefile2. If modulefile1
		is not specified, then it is assumed to be the currently
		loaded module with the same root name as modulefile2.
" 1>&2
	std::die 1
}

subcommand_help_swap() {
	subcommand_help_switch
}

subcommand_help_display() {
	echo "
USAGE:
        module display modulefile...
        module show    modulefile...
		Display information about one or more modulefiles.  The
		display sub-command will list the full path of the
		modulefile(s) and all (or most) of the environment changes
		the modulefile(s) will make if loaded.  It will not display
		any environment changes found within conditional statements.
" 1>&2
	std::die 1
}

subcommand_help_show() {
	subcommand_help_display
}

subcommand_help_apropos() {
	echo "
USAGE:
        module apropos string
        module keyword string	Seeks through the 'whatis' informations of all modulefiles for
		the specified string.  All module-whatis informations matching
		the string will be displayed.
		
" 1>&2
	std::die 1
}

subcommand_help_keyword() {
	subcommand_help_apropos
}


subcommand_help_avail() {
	echo "
USAGE:
        module avail [switches] string
		List all available modulefiles in the current MODULEPATH. If
		an argument is given, then each directory in the MODULEPATH
		is searched for modulefiles whose pathname match the argument.

		This command does *not* display all installed modules on the
		system. Only *loadable* modules are listed.  The list of 
		available modules may change either by loading other modules,
		e.g. a compiler, or with the sub-command 'use'.

SWITCHES:
        -a|--all||--all-releases
		List all available modules independend of the release.
		
	-t|--terse
		Output in short format.

	-l|--long
		Output in long format.

	-h|--human
		Output in human readable format.
	-m|--machine
		Output in machine readable format
" 1>&2
	std::die 1
}

subcommand_help_search() {
	echo "
USAGE:
        module search [switches] string...
		Search installed modules. If an argument is given, search
		for modules whose name match the argument.

SWITCHES: 
        --no-header
		Suppress output of a header.

        --release=RELEASE
		Search for modules within this release. You can specify this
		switch multiple times.  Without this switch, the used releases
		will be searched.

        -a|--all-releases
		Search within all releases.
		
        --with=STRING
		Search for modules compiled with modules matching string. The
		command

		module search --with=gcc/4.8.3

		lists all modules in the hierarchy compiled with gcc 4.8.3.
" 1>&2
	std::die 1
}

subcommand_help_use() {
	echo "
USAGE:
        module use [-a|--append|-p|--prepend] [directory|group|release...]
		Without arguments this sub-command displays information about
		the module search path, used families and releases. You can
		use this sub-command to get a list of available families and
		releases.

		With a directory as argument, this directory will either be
		prepended or appended to the module search path. The default
		is to prepend the directory.

		With a group as argument, the modules in this group will 
		be made available.

		With a release as argument, this modules with this release
		will be made available.

SWITCHES:
        -a | --append -p | --prepend )
                Append/prepend agrument to module search path or list of to be
                searched releases.
" 1>&2
	std::die 1
}

subcommand_help_unuse() {
	echo "
unuse directory|group|release...
		Remove the given directory, group or release from the search
		path.
" 1>&2
	std::die 1
}
subcommand_help_update() {
	echo "
USAGE:
        module update
                Attempt  to  reload  all  loaded  modulefiles.
" 1>&2
	std::die 1
}

subcommand_help_refresh() {
	echo "
USAGE:
        module refresh
                Force a refresh of all non-persistent components of currently
		loaded modules.  This should be used on derived shells where
		aliases need to be reinitialized but the environment variables
		have already been set by the currently loaded modules.
" 1>&2
	std::die 1
}

subcommand_help_purge() {
	echo "
USAGE:
        module purge
		Unload all loaded modulefiles.
" 1>&2
	std::die 1
}

subcommand_help_list() {
	echo "
USAGE:
        module list
		List loaded modules.
" 1>&2
	std::die 1
}

subcommand_help_clear() {
	echo "
USAGE:
        module clear
		Force the Modules package to believe that no modules are
		currently loaded.
" 1>&2
	std::die 1
}

subcommand_help_whatis() {
	echo "
USAGE:
        module whatis [modulefile...]
                Display the information set up by the module-whatis commands
		inside the specified modulefile(s). If no modulefile is
		specified, all 'whatis' lines will be shown.
" 1>&2
	std::die 1
}

subcommand_help_initadd() {
	echo "
USAGE:
        module initadd	modulefile...
		Add modulefile(s) to the shell's initialization file in the
		user's home directory.  The startup files checked (in order)
		are:

                    csh -   .modules, .cshrc(.ext), .csh_variables, and
                            .login(.ext)
                    tcsh -  .modules, .tcshrc, .cshrc(.ext), .csh_variables,
                            and .login(.ext)
                    (k)sh - .modules, .profile(.ext), and .kshenv(.ext)
                    bash -  .modules, .bash_profile, .bash_login,
                            .profile(.ext) and .bashrc(.ext)
                    zsh -   .modules, .zcshrc(.ext), .zshenv(.ext), and
                            .zlogin(.ext)

                If a 'module load' line is found in any of these files, the
                modulefile(s) is(are) appended to any existing list of 
                modulefiles.  The 'module load' line must be located in at
                least one of the files listed above for any of the 'init'
                sub-commands to work properly.  If the 'module load' line
                line is found in multiple shell initialization files, all
		of the lines are changed.
" 1>&2
	std::die 1
}

subcommand_help_initprepend() {
	echo "
USAGE:
        module initprepend modulefile...
		Does the same as initadd but prepends the given modules to
		the beginning of the list.
" 1>&2
	std::die 1
}

subcommand_help_initrm() {
	echo "
USAGE:
        module initrm modulefile...
		Remove modulefile(s) from the shell's initialization files.
" 1>&2
	std::die 1
}

subcommand_help_initswitch() {
	echo "
USAGE:
        module initswitch modulefile1 modulefile2
		Switch modulefile1 with modulefile2 in the shell's initialization files.
" 1>&2
	std::die 1
}

subcommand_help_initlist() {
	echo "
USAGE:
        module initlist
		List all of the modulefiles loaded from the shell's initialization file.
" 1>&2
	std::die 1
}

subcommand_help_initclear() {
	echo "
USAGE:
	module initclear
		Clear all of the modulefiles from the shell's initialization files.
" 1>&2
	std::die 1
}

#
# get release of module
# Note:
# - the release of a modulefile outside ${PMODULES_ROOT} is 'stable'
# - the release of a modulefile inside ${PMODULES_ROOT} without a 
#   coresponding release file is 'unstable'
#
# Args:
# 	$1: absolute modulefile name
#
get_release() {
	local -r modulefile=$1

	# is modulefile outside ${PMODULES_ROOT}?
	if [[ ! ${modulefile} =~ ${PMODULES_ROOT} ]]; then
		echo 'stable'
		return 0
	fi

	# we are inside ${PMODULES_ROOT}
	local -r releasefile="${modulefile%/*}/.release-${modulefile##*/}"
	if [[ -r ${releasefile} ]]; then
		# read releasefile, remove empty lines, spaces etc
		local -r data=$( < "${releasefile}" )
		echo ${data}
	else	
		echo 'unstable'
	fi
	return 0
}

: ${PMODULES_DEFINED_RELEASES:=':unstable:stable:deprecated:'}

is_release() {
	[[ ${PMODULES_DEFINED_RELEASES} =~ :$1: ]]
}

is_used_release() {
	[[ ":${UsedReleases}:" =~ :$1: ]]
}

declare used_groups=":${PMODULES_USED_GROUPS}:"

is_group () {
	local -r group="$1"
	# arg isn't emtpy and group already in cache
	[[ -n ${group} ]] && [[ -n ${GroupDepths[${group}]} ]] && return 0

	# not yet cached or not a group
	if [[ -d "${PMODULES_ROOT}/${group}/${PMODULES_MODULEFILES_DIR}" ]]; then
		Groups+=( "${group}" )
		get_group_depths "${PMODULES_ROOT}" "${group}"
	fi
	return 1
}

is_used_group() {
	[[ ${used_groups} =~ :$1: ]]
}

module_is_loaded() {
	[[ :${LOADEDMODULES}: =~ :$1: ]]
}

#
# check shebang
# $1: file name to test
is_modulefile() {
	local -r fname=$1
	local shebang
	[[ -r ${fname} ]] || return 1
	read -n 11 shebang < "${fname}"
	[[ "${shebang}" == "#%Module1.0" ]]
}

subcommand_generic0() {
	local -r subcommand=$1
	shift
	local opts=''
	opts=$(pmodules::get_options -- '' "$@") || subcommand_help_${subcommand}
	eval set --  "${opts}"
	while (( $# > 0 )); do
		case $1 in
			-- )
				shift
				;;
			* )
				std::die 3 "${CMD} ${subcommand}: illegal argument -- $1"
				;;
		esac
	done
	"${modulecmd}" "${g_shell}" "${subcommand}"
}

subcommand_generic1() {
	local -r subcommand=$1
	shift
	local opts=''
	opts=$(pmodules::get_options -- '' "$@") || subcommand_help_${subcommand}
	eval set --  "${opts}"
	local args=()
	while (( $# > 0 )); do
		case $1 in
			-- )
					;;
			* )
				if (( ${#args[@]} == 0 )); then
				        args+=( "$1" )
				else
					std::die 3 "${CMD} ${subcommand}: only one argument allowed"
				fi
				;;
		esac
		shift
	done
	if (( ${#args[@]} == 0 )); then
	        std::die 3 "${CMD} ${subcommand}: missing argument"
	fi
	"${modulecmd}" "${g_shell}" "${subcommand}" "${args[@]}"
}

subcommand_generic1plus() {
	local -r subcommand=$1
	shift
	local opts=''
	opts=$(pmodules::get_options -- '' "$@") || subcommand_help_${subcommand}
	eval set --  "${opts}"
	local args=()
	while (( $# > 0 )); do
		case $1 in
			-- )
				;;
			* )
				args+=( "$1" )
				;;
		esac
		shift
	done
	if (( ${#args[@]} == 0 )); then
	        std::die 3 "${CMD} ${subcommand}: missing argument"
	fi
	"${modulecmd}" "${g_shell}" "${subcommand}" "${args[@]}"
}

subcommand_generic1or2() {
	local -r subcommand=$1
	shift
	local opts=''
	opts=$(pmodules::get_options -- '' "$@") || subcommand_help_${subcommand}
	eval set --  "${opts}"
	local args=()
	while (( $# > 0 )); do
		case $1 in
			-- )
				;;
			* )
				if (( ${#args[@]} > 2 )); then
					std::die 3 "${CMD} ${subcommand}: only one or two arguments are allowed"
				fi
				args+=( "$1" )
				;;
		esac
		shift
	done
	if (( ${#args[@]} == 0 )); then
	        std::die 3 "${CMD} ${subcommand}: missing argument"
	fi
	"${modulecmd}" "${g_shell}" "${subcommand}" "${args[@]}"
}

#
# load [-fsvw] <module>
# 
# $1: module to load
#
subcommand_load() {
	local release='undef'
	local moduledir=''
	local m=''

	local saved_IFS=${IFS}; 
	IFS=':'
	local -a modulepath=(${MODULEPATH})
	IFS=${saved_IFS}
	local -r saved_MODULEPATH=${MODULEPATH}
	local -a saved_modulepath=${modulepath}
	local -r saved_UsedReleases=${UsedReleases}

	#
	# Test whether a given module can be loaded according to the 
	# accepted releases.
	#
	# Notes:
	#	The variable 'release' in function 'subcommand_load()' will be set.
	#	The release of a modulefile outsite our hierarchy is 'stable'.
	#
	# $1: absolute name of modulefile
	#
	is_loadable() {
		release=$( get_release "$1" )			
		[[ :${UsedReleases}: =~ ${release} ]] && return 0
		return 1
	}

	#
	# Test whether a given module is available.
	# The passed module-name can be
	#
	# - an absolute file- or link-name.
	#   The module can be either in- or outside our hierarchy.
	#
	# - a relative file- or link-name.
	#   The module can be either in- or outside out hierarchy.
	#
	# - specified with name and version (like gcc/5.2.0).
	#   The module can be either in- or outside our hierarchy.
	#
	# - specified with name only (without version, like gcc).
	#   The module can be either in- or outside our hierarchy.
	#
	# - ?directory in- or outsite our hierarchy (not supported by modulecmd.tcl!)
	#
	# arguments:
	# 	$1: module name or file
	#
	# possible return values:
	# 	0: module is loadable
	# 	1: nothing found
	# 	2: not a modulefile (shebang is wrong)
	# 	3: the release of the module is not in use
	#	4: inside our hierarchy but not a loadable module-file
	#
	# Notes:
	#	The variable 'release' in function 'subcommand_load()' will be set.
	#	The variable 'm' in function 'subcommand_load()' may be set.
	#
	is_available() {
		local  m=$1

		if [[ -f ${m} ]]; then
			# the passed argument is a modulefile
			if [[ "${m:0:1}" != "/" ]]; then
				# file-name is relative
				m=$(std::get_abspath "${m}")
			fi
			# from here on we have an absolute file name
			is_modulefile "${m}" || return 2
			is_loadable "${m}"   || return 3
			if [[ "${m}" =~ "${PMODULES_ROOT}" ]]; then
				for dir in "${modulepath[@]}"; do
					[[ "${m}" =~ "${dir}" ]] && return 0
				done
				# inside hierarchy, but not loadable
				return 4
			fi
			current_modulefile="${m}"
			return 0
		fi

		# the argument is a module name
		# check whether $m is in our modulepath
		for dir in "${modulepath[@]}"; do
			if [[ -d ${dir}/$1 ]]; then
				# module specified without version, like 'hdf5'
				while read fname; do
					is_modulefile "${fname}" || return 2
					if is_loadable "${fname}"; then
						moduledir="${dir}"
						current_modulefile="${fname}"
						return 0
					fi
				done < <(find "${dir}/$1" -mindepth 1 -maxdepth 1 -type l -o -type f  \! -name ".*")
			else
				# module specified with name/version, like 'hdf5/1.8.14'
				[[ -f ${dir}/$1 ]] || continue
 				[[ -r ${dir}/$1 ]] || continue
				is_modulefile "${dir}/$1" || return 2
		        	if is_loadable "${dir}/$1"; then
					moduledir="${dir}"
					current_modulefile="${dir}/$1"
					return 0
				fi
			fi
		done
		return 1
	}

	#
	# output load 'hints'
	#
	# Note:
	#	The variable 'm' from the parent function will be used
	#	but not changed.
	#
	# Args:
	#	none
	output_load_hints() {
		local -ra rels=( ${PMODULES_DEFINED_RELEASES//:/ } )
		for rel in "${rels[@]}"; do
			eval $( subcommand_use "${rel}" )
			if is_available "${m}"; then
				std::info "${m}: is ${rel}! If you want to load this module, run"
				std::info "\tmodule use ${rel}"
				std::info "before running"
				std::info  "\tmodule load ${m}"
				exit 42
			fi
		done
		local something_found='no'
		local -a output=()
		local -a release=()
		local -a loadable=()
		local -i i=0
		local -i n=0
		while read -a line; do
			output[n]="module load ${line[@]:3} ${line[0]}"
			release[n]=${line[1]}
			if [[ ":${UsedReleases}:" =~ "${release[n]}" ]]; then
				loadable[n]='yes'
			else
				loadable[n]='no'
			fi
			n+=1
		done < <(subcommand_search  "${m}" -a --no-header 2>&1)
		if (( n == 0 )); then
		        std::info "${CMD} load: module unavailable -- ${m}"
		else
			# :FIXME: output group
			std::info "\nThe module '${m}' is not available with the  " \
				  "currently loaded modules!" \
				  "You may try: "
			for ((i=n-1; i >=0; i--)); do
				if [[ "${loadable[i]}" == "no" ]]; then
 				        std::info "${output[i]}\t# ${release[i]}"
				else
					std::info "${output[i]}"
				fi
			done
		fi
	}

	load_dependencies() {
		local -r fname="$1"
		echo "loading dependencies from $fname" 1>&2
		while read dep; do
			[[ -z ${dep} ]] && continue
			[[ ${dep:0:1} == \# ]] && continue
			local output=$( subcommand_load "${dep}")
			echo ${output}
			eval ${output}
		done < "${fname}"
	}

	local opts
	opts=$(pmodules::get_options -o fsvw -l force -l silent -l verbose -l warn -- "$@") || \
	    subcommand_help_load
	eval set --  "${opts}"
	local args=()
	opts=''
	while (($# > 0)); do
		case $1 in
			-f | --force )
				opts+=' -f'
				;;
			-s | --silent )
				verbosity_lvl='silent'
				;;
			-v | --verbose )
				verbosity_lvl='verbose'
				;;
			-w | --warn )
				verbosity_lvl='warn'
				;;
			-- )
				;;
			* )
				args+=( $1 )
				;;
			esac
			shift
	done
	if (( ${#args[@]} == 0 )); then
		std::die 2 "${CMD} load: No module specified."
	fi
	for m in "${args[@]}"; do
		# restore original MODULEPATH; it might have been overwritten
		MODULEPATH=${saved_MODULEPATH}
		modulepath=${saved_modulepath}
		UsedReleases=${saved_UsedReleases}
		if [[ "$m" =~ ":" ]]; then

			# extendet module name is either
			# - group:name or
			# - group:name:release or
			# - release:name or
			# - release:group:name or
			# - name:release

			local save_ifs=${IFS}
			IFS=':'
			local -a toks=($m)
			IFS=${save_ifs}
			local group=''
			local release=''
			if is_group "${toks[0]}"; then
				group=${toks[0]}
				m=${toks[1]}
				release=${toks[2]}
			elif is_release "${toks[0]}"; then
				release=${toks[0]}
				if is_group "${toks[1]}"; then
					group=${toks[1]}
					m=${toks[2]}
				else
					m=${toks[1]}
					group=${toks[2]}
				fi
			else
				m=${toks[0]}
				if is_group "${toks[1]}"; then
					group=${toks[1]}
					release=${toks[2]}
				else
					release=${toks[1]}
					group=${toks[2]}
				fi
			fi
			if [[ -n ${group} ]]; then
				is_group "${group}" || std::die 3 "${CMD} load: illegal group name."
				local -i depth=${GroupDepths[${group}]}
				(( depth != 0 )) && std::die 3 "${CMD} load: illegal group name."
				MODULEPATH="${PMODULES_ROOT}/${group}/${PMODULES_MODULEFILES_DIR}"
				modulepath=( ${MODULEPATH} )
			fi
			if [[ -n ${release} ]]; then
			        is_release "${release}" || \
				    std::die 3 "${CMD} load: illegal release name."
				std::append_path UsedReleases "${release}"
			fi
		fi 
		if ! is_available "${m}"; then
			if [[ ${verbosity_lvl} == 'verbose' ]]; then
			        output_load_hints
			else
				std::die 3 "${CMD} load: module unavailable -- ${m}"
			fi
			continue
		fi
		if [[ ${current_modulefile} =~ ${PMODULES_ROOT} ]]; then
			# modulefile is in our hierarchy:
			# compute installation prefix
			local tmp=${current_modulefile#${PMODULES_ROOT}/}
			tmp=${tmp/${PMODULES_MODULEFILES_DIR}\/}
			local save_IFS="${IFS}"
			IFS='/'
			local -a toks=( ${tmp} )
			IFS="${save_IFS}"
			# reverse remaining path items pairwise
			local p=""
			for ((i=1; i<${#toks[@]}; i+=2)); do
				p="/${toks[i]}/${toks[i+1]}${p}"
			done
			local dependencies="${PMODULES_ROOT}/${toks[0]}${p}/.dependencies"
			if [[ -r ${dependency_info} ]]; then
				echo $dependencies 1>&2
				load_dependencies "${dependencies}"
			fi
		fi
		"${modulecmd}" "${g_shell}" ${opts} load "${m}"
		if [[ ${verbosity_lvl} != silent ]] && [[ ${release} != stable ]]; then
			std::info "Warning: the ${release} module '${m}' has been loaded."
		fi
	done
	# restore original MODULEPATH; it might have been overwritten
	MODULEPATH=${saved_MODULEPATH}
	UsedReleases=${saved_UsedReleases}
}

#
# unload <module>
#
subcommand_unload() {
	# :FIXME: add dependency tests: don't unload if module is required be
	#	  another module
	while (( $# > 0 )); do
		subcommand_generic1 unload "$1"
		shift
	done
}

#
# swap <module> [<module>]
#
subcommand_swap() {
	subcommand_generic1or2 swap "$@"
}

#
# show <module>
#
subcommand_show() {
	while (( $# > 0 )); do
		subcommand_generic1 show "$1"
		shift
	done
}

#
# get all available modules in given directory.
# return list like
#	modulename1 release1 modulename2 release2 ...
#
get_available_modules() {
	local -r dir=$1
	local -r module=$2
	local -r use_releases=${3:-${UsedReleases}}
	local -a mods=()
	while read mod; do
		local release=$( get_release "${dir}/${mod}" )

		if [[ :${use_releases}: =~ :${release}: ]]; then
		        mods+=( "${mod}" ${release} )
		fi
	done < <(MODULEPATH="${dir}" "${modulecmd}" bash -t avail "${module}" 2>&1 | tail -n +2)
	echo "${mods[@]}"
}

#
# avail [-hlt] [<module-pattern>...]
#
subcommand_avail() {
	# use this variable in the output functions
	local -a mods=()
	local dir=''
	
	# get number of columns of terminal
	cols=$(tput cols)

	output_header() {
		local caption=${dir/${PMODULES_ROOT}\/}
		local caption=${caption/\/${PMODULES_MODULEFILES_DIR}/: }
		local caption=${caption/: \//: }
		let i=($cols-${#caption})/2-2
		printf -- "%0.s-" $(seq 1 $i) 1>&2
		printf -- " %s " "${caption}" 1>&2
		printf -- "%0.s-" $(seq 1 $i) 1>&2
		printf -- "\n" 1>&2
	}

	terse_output() {
		output_header
		for (( i=0; i<${#mods[@]}; i+=2 )); do
			local mod=${mods[i]}
			local release=${mods[i+1]}
			case $release in
				stable )
					out=''
					;;
				* )
					out="${release}"
					;;
			esac
			printf "%-20s\t%s\n" "${mod}" "${out}" 1>&2
		done
		std::info ""
	}

	machine_output() {
		for (( i=0; i<${#mods[@]}; i+=2 )); do
			printf "%-20s\t%s\n" "${mods[i]}" "${mods[i+1]}" 1>&2
		done
	}

	#
	# :FIXME: for the time being, this is the same as terse_output!
	long_output() {
		output_header
		for (( i=0; i<${#mods[@]}; i+=2 )); do
			local mod=${mods[i]}
			local release=${mods[i+1]}
			case $release in
				stable )
					out=''
					;;
				* )
					out=${release}
					;;
			esac
			printf "%-20s\t%s\n" "${mod}" "${out}" 1>&2
		done
		std::info ""
	}

	human_readable_output() {
		output_header

		local -i column=$cols
		local -i colsize=16
		for ((i=0; i<${#mods[@]}; i+=2)); do
			if [[ ${verbosity_lvl} == 'verbose' ]]; then
			        local  release=${mods[i+1]}
			        case ${mods[i+1]} in
					stable )
						mod=${mods[i]}
						;;
					* )
						mod="${mods[i]}(${release:0:1})"
						;;
				esac
			else
				mod=${mods[i]}
			fi
			local -i len=${#mod}
			local -i span=$(( len / 16 + 1 ))
			local -i colsize=$(( span * 16 ))
			if (( column+len >= cols )); then
			        printf -- "\n" 1>&2
				column=0
			fi
			if (( column+colsize < cols )); then
			        fmt="%-${colsize}s"
			else
				fmt="%-s"
			fi
			printf "${fmt}" "${mod}" 1>&2
			column+=colsize
		done
		printf -- "\n\n" 1>&2
	}
	local opts=''
	opts=$(pmodules::get_options -o ahlmt \
			-l all -l all-releases \
			-l human -l long -l machine -l terse -- "$@") || subcommand_help_avail
	eval set --  "${opts}"
	local pattern=()
	local output_function=''
	local opts=''
	local opt_all_groups='no'
	local opt_use_releases="${UsedReleases}"
	while (($# > 0)); do
		case $1 in
			-a | --all )
				opt_all_groups='yes'
				opt_use_releases="${PMODULES_DEFINED_RELEASES}"
				;;
			--all-releases )
				opt_use_releases="${PMODULES_DEFINED_RELEASES}"
				;;
			-h | --human )
				[[ -z ${opts} ]] || \
				    std::die 1 "${CMD} list: you cannot set both options: '$1' and '${opts}'."
				opts=$1
				output_function='human_readable_output'
				;;
			-l | --long )
				[[ -z ${opts} ]] || \
				    std::die 1 "${CMD} list: you cannot set both options: '$1' and '${opts}'."
				opts=$1
				output_function='long_output'
				;;
			-t | --terse )
				[[ -z ${opts} ]] || \
				    std::die 1 "${CMD} list: you cannot set both options: '$1' and '${opts}'."
				opts=$1
				output_function='terse_output'
				;;
			-m | --machine )
				[[ -z ${opts} ]] || \
				    std::die 1 "${CMD} list: you cannot set both options: '$1' and '${opts}'."
				opts=$1
				output_function='machine_output'
				;;
			-- )
				;;
			* )
				pattern+=( "$1" )
				;;
		esac
		shift
	done
	output_function=${output_function:-human_readable_output}
	if [[ "${opt_all_groups}" = 'yes' ]]; then
		rescan_groups
	fi
	if (( ${#pattern[@]} == 0 )); then
	        pattern+=( '' )
	fi
	local saved_IFS=${IFS}; 
	IFS=':'
	local -a modulepath=(${MODULEPATH})
	IFS=${saved_IFS}
	for string in "${pattern[@]}"; do
		for dir in "${modulepath[@]}"; do
			mods=( $( get_available_modules "${dir}" "${string}" "${opt_use_releases}" ) )
			[[ ${#mods[@]} == 0 ]] && continue

			${output_function}
		done
	done
}

# get available groups
# $1: root of modulefile hierarchy
#
get_groups () {
	local -r root="$1"
	{
		cd "${root}" 
		# for some unknown reason [A-Z]* doesn't work on (some?) SL6 systems
		for f in [ABCDEFGHIJKLMNOPQRSTUVWXYZ]*; do
			Groups+=( $f )
		done
	};
}

# compute depths or passed group
# Note: cwd must be Pmodules root directory
# $1: group
#
get_group_depth2 () {
	local -r group="$1"
	local  tmp=$(find "${group}/${PMODULES_MODULEFILES_DIR}" -depth -type f -o -type l | head -1)
	local -a tmp2=( ${tmp//\// } )
	local depth=${#tmp2[@]}
	(( depth-=4 ))
	GroupDepths[$group]=${depth} 
}

# compute depths or passed group
# $1: root
# $2: group
#
get_group_depth2 () {
	local -r root="$1"
	local -r group="$2"

	{
		cd "${root}"
		get_group_depth2 "${group}"
	}
}

#
# Compute depth for all known groups
# $1: root of modulefile hierarchy
get_group_depths () {
	local -r root="$1"
	{
		cd "${root}"
		local group
		for group in "${Groups[@]}"; do
			get_group_depth2 "${group}"
		done
	};
}

# re-scan available groups.
#
# Note:
# Removing groups is not supported for the time being. Be aware, that 
# a user might have a module loaded from this group. This cannot be checked.
#
# $1: root of modulefile hierarchy
rescan_groups() {
	local -r root="$1"
	{
		cd "${root}" 
		# for some unknown reason [A-Z]* doesn't work with some bash versions
		for group in [ABCDEFGHIJKLMNOPQRSTUVWXYZ]*; do
			if [[ -z "${GroupDepths[${group}]}" ]]; then
				Groups+=( "${group}" )
				get_group_depth2 "${group}"
			fi
		done
	};
}

#
# use [-a|--append|-p|--prepend] [directory|group|release...]
#
subcommand_use() {
	if (( ${#Groups[@]} == 0 )); then
	        get_groups "${PMODULES_ROOT}"
		get_group_depths "${PMODULES_ROOT}"
	fi
	local saved_IFS=${IFS}; 
	IFS=':'
	local -a modulepath=(${MODULEPATH})
	IFS=${saved_IFS}

	print_info() {
		local f
		local r
		std::info "Used groups:"
		for f in ${used_groups//:/ }; do
			std::info "\t${f}"
		done
		std::info "\nUnused groups:"
		local _group
		for _group in "${Groups[@]}"; do
			local -i depth=${GroupDepths[${_group}]}
			if ! is_used_group "${_group}" && (( depth == 0 )); then
			    std::info "\t${_group}"
			fi
		done
		
		std::info "\nUsed releases:"
		for r in ${UsedReleases//:/ }; do
			std::info "\t${r}"
		done
		std::info "\nUnused releases:"
		for r in ${PMODULES_DEFINED_RELEASES//:/ }; do
			if ! is_used_release $r; then
				std::info "\t${r}"
			fi
		done

		std::info "\nAdditonal directories in MODULEPATH:"
		let n=0
		for (( i=0; i<${#modulepath[@]}; i++)); do
			if [[ ! ${modulepath[i]} =~ ${PMODULES_ROOT} ]]; then
			        std::info "\t${modulepath[i]}"
			        let n+=1
			fi
		done
		if (( n == 0 )); then
		        std::info "\tnone"
		fi
		std::info "\n"
	}

	use () {
		
		local dirs_to_add=()
		local subcommand_switches=''
		while (( $# > 0)); do
			if [[ "$1" == "--" ]]; then
				shift
			        continue
			fi
			arg=$1
			# if is release
			# ...
			# elif is group
			# ...
			# elif matches modulepath root
			# ...
			# elif is directory
			# ...
			local modulefiles_dir="${PMODULES_ROOT}/${arg}/${PMODULES_MODULEFILES_DIR}"
			if [[ ${arg} == -a ]] || [[ ${arg} == --append ]]; then
			        subcommand_switches='--append'
			elif [[ ${arg} == -p ]] || [[ ${arg} == --prepend ]]; then
			        subcommand_switches=''
			elif is_release "${arg}"; then
			        # releases are always *appended*
			        std::append_path UsedReleases "${arg}"
			elif [[ ! ${arg} =~ */* ]] && [[ -d ${modulefiles_dir} ]]; then
				if [[ -z "${GroupDepths[$arg]}" ]]; then
					# not yet cached group
					Groups+=( "${arg}" )
					get_group_depth "${PMODULES_ROOT}" "${arg}"
				fi
				if (( ${GroupDepths[$arg]} != 0 )); then
					std::die 3 "${CMD} ${FUNCNAME[0]##*_}: cannot add group ${arg} to module path"
				fi
				std::append_path PMODULES_USED_GROUPS "${arg}"
			       	dirs_to_add+=( ${modulefiles_dir} )
			elif [[ ${arg} =~ ^${PMODULES_ROOT} ]]; then
				std::die 3 "${CMD} ${FUNCNAME[0]##*_}: illegal directory: ${arg}"
			elif [[ -d ${arg} ]]; then
			        local normalized_dir=$(cd "${arg}" && pwd)
				dirs_to_add+=( ${normalized_dir} )
			else
				std::die 3 "${CMD} ${FUNCNAME[0]##*_}: neither a directory, release or group: ${arg}"
			fi
			shift
		done

		declare -g PMODULES_USED_GROUPS="${PMODULES_USED_GROUPS}"
		pbuild::export_env ${g_shell} PMODULES_USED_GROUPS
		[[ ${#dirs_to_add[@]} == 0 ]] && return

		for dir in "${dirs_to_add[@]}"; do
			subcommand_generic1 use ${subcommand_switches} "${dir}"
		done
	}

	local opts=''
	opts=$(pmodules::get_options -o 'ap' -l 'append' -l 'prepend' -- "$@") || subcommand_help_use
	eval set --  "${opts}"
	
	if [[ $# == 1 ]]; then
	        print_info
	else
		use "$@"
	fi
}

#
# unuse directory|group|release...
#
subcommand_unuse() {
	local opts=''
	opts=$(pmodules::get_options -o '' -- "$@") || subcommand_help_unuse
	eval set --  "${opts}"
	local dirs_to_remove=()
	while (( $# > 0)); do
		if [[ "$1" == "--" ]]; then
		        shift
			continue
		fi
		arg=$1
		# if is release
		# ...
		# elif is group
		# ...
		# elif matches modulepath root
		# ...
		# elif is directory
		# ...
		local modulefiles_dir="${PMODULES_ROOT}/${arg}/${PMODULES_MODULEFILES_DIR}"
		if is_release "${arg}"; then
			std::remove_path UsedReleases "${arg}"
		elif [[ ! ${arg} =~ */* ]] &&  [[ -d ${modulefiles_dir} ]]; then
			if (( ${GroupDepths[$arg]} != 0 )); then
				std::die 3 "${CMD} ${FUNCNAME[0]##*_}: cannot remove group ${arg} from module path"
			fi
			std::remove_path PMODULES_USED_GROUPS "${arg}"
			dirs_to_remove+=( ${modulefiles_dir} )
		elif [[ -d ${arg} ]]; then
			local normalized_dir=$(cd "${arg}" && pwd)
			dirs_to_remove+=( ${normalized_dir} )
		elif [[ ${arg} =~ ^${PMODULES_ROOT} ]]; then
			std::die 3 "${CMD} ${FUNCNAME[0]##*_}: illegal directory: ${arg}"
		else
			std::die 3 "${CMD} ${FUNCNAME[0]##*_}: not a directory: ${arg}"
		fi
		shift
	done
	#echo "export PMODULES_USED_GROUPS=${PMODULES_USED_GROUPS}"
	declare -g PMODULES_USED_GROUPS="${PMODULES_USED_GROUPS}"
	pbuild::export_env ${g_shell} PMODULES_USED_GROUPS
	[[ ${#dirs_to_remove[@]} == 0 ]] && return
	for dir in "${dirs_to_remove[@]}"; do
		subcommand_generic1 unuse "${dir}"
	done
}

#
# update
#
# :FIXME: either compile Modules with --enable-beginenv or remove the sub-command
#
subcommand_update() {
	subcommand_generic0 update "$@"
}

#
# refresh
#
subcommand_refresh() {
	subcommand_generic0 refresh "$@"
}

##############################################################################
#
# purge
#
subcommand_purge() {
	subcommand_generic0 purge "$@"
}

##############################################################################
#
# list [-hlt]
#
subcommand_list() {
	local opts=''
	opts=$(pmodules::get_options -o hlt -l human -l long -l terse -- "$@") || subcommand_help_list
	eval set --  "${opts}"
	local opts=''
	while (( $# > 0 )); do
		case $1 in
			-h | --human )
				[[ -z ${opts} ]] || \
				    std::die 1 "${CMD} list: you cannot set both options: '$1' and '${opts}'."
				opts='-h'
				;;
			-l | --long )
				[[ -z ${opts} ]] || \
				    std::die 1 "${CMD} list: you cannot set both options: '$1' and '${opts}'."
				opts='-l'
				;;
			-t | --terse )
				[[ -z ${opts} ]] || \
				    std::die 1 "${CMD} list: you cannot set both options: '$1' and '${opts}'."
				opts='-t'
				;;
			-- )
				;;
			* )
				std::die 1 "${CMD} list: invalid argument -- $1"
				;;
		esac
		shift
	done
	"${modulecmd}" "${g_shell}" list "${opts}"
}

##############################################################################
pmodules_init() {
	declare -g PMODULES_DEFAULT_GROUPS=''
	declare -g PMODULES_DEFAULT_RELEASES=''

	source "${PMODULES_ROOT}/${PMODULES_CONFIG_DIR}/environment.bash"

	declare -g LOADEDMODULES=''
	declare -g PMODULES_USED_GROUPS=''
	declare -g MODULEPATH=''
	declare -g _LMFILES_=''

	for group in ${PMODULES_DEFAULT_GROUPS}; do
		std::append_path MODULEPATH "${PMODULES_ROOT}/${group}/${PMODULES_MODULEFILES_DIR}"
		std::append_path PMODULES_USED_GROUPS "${group}"
	done
	declare -ag Groups='()'
	declare -Ag GroupDepths='()'
	declare -g  UsedReleases=''
	for r in ${PMODULES_DEFAULT_RELEASES//:/ }; do
		std::append_path UsedReleases "${r}"
	done

}

##############################################################################
#
# clear
#
subcommand_clear() {
	local -r subcommand="${FUNCNAME##*_}"
	local opts=''
	opts=$(pmodules::get_options -- '' "$@") || subcommand_help_${subcommand}
	eval set --  "${opts}"
	while (( $# > 0 )); do
		case $1 in
			-- )
				shift
				;;
			* )
				std::die 3 "${CMD} ${subcommand}: illegal argument -- $1"
				;;
		esac
	done
	pmodules_init
	pbuild::export_env ${g_shell} LOADEDMODULES PMODULES_USED_GROUPS MODULEPATH _LMFILES_
}

##############################################################################
#
# search [switches] [STRING...]
#
subcommand_search() {
	local -r subcommand="${FUNCNAME##*_}"
	local modules=()
	local with_modules='//'
	local src_prefix=''
	local opt_print_header='yes'
	local opt_print_modulefiles='no'
	local opt_print_variants='no'
	local opt_use_releases=':'
	local -r fmt="%-20s %-10s %-12s %-s\n"

	# no args
	print_header() {
		printf '\n' 1>&1
		printf "${fmt}" "Module" "Release" "Group" "Requires" 1>&2
		printf -- '-%.0s' {1..60} 1>&2
		printf '\n' 1>&2
	}

	#.....................................................................
	#
	# output result of search
	# Args:
	#   $1: tmp file
	#
	# variables used from enclosing function:
	#   opt_print_header
	#   opt_print_modulefiles
	#   opt_print_variants
	#   with_modules
	#
	print_result() {
		local -r tmpfile=$1
		[[ "${opt_print_header}" == "yes" ]] && print_header
		if [[ "${opt_print_modulefiles}" == "yes" ]]; then
			while read -a line; do
				# group first
				local out="${line[2]}/"
				# add directory of modulefiles
				out+="${PMODULES_MODULEFILES_DIR}/"
				for d in "${line[@]:3}"; do
					out+="$d/"
				done
				out+="${line[0]}"
				std::info "${out}"
			done < <(sort -k 1,1 -k 4,4 -k 5,5 "${tmpfile}" | awk "${with_modules}")
		elif [[ "${opt_print_variants}" == "yes" ]]; then
			while read -a toks; do
				unset deps

				# build prefix for this module
				local prefix="${PMODULES_ROOT}/${toks[2]}/${toks[0]}/"
				for ((i=${#toks[@]}-1; i>=3; i--)); do
					prefix+="${toks[i]}/"
				done
				# read dependencies
				local -a ordered_deps=()
				local d
				local -A deps
				if [[ -r "${prefix}/.build_dependencies" ]]; then
					readarray -t ordered_deps < "${prefix}/.build_dependencies"
					for d in "${ordered_deps[@]}"; do
						[[ -z $d ]] && continue
						deps[$d]='b:'
					done
				fi
				if [[ -r "${prefix}/.dependencies" ]]; then
					local -a rdeps
					readarray -t rdeps < "${prefix}/.dependencies"
					for d in "${rdeps[@]}"; do
						[[ -z $d ]] && continue
						if [[ ${deps[$d]+isset} ]]; then
							# is a build- and run-time dependency
							deps[$d]=''
						else
							# is a run-time dependency only
							ordered_deps+=( "$d" )
							deps[$d]='r:'
						fi
					done
				fi
				local dependecies=''
				for d in "${ordered_deps[@]}"; do
					[[ -z $d ]] && continue
					dependecies+="${deps[$d]}$d "
				done
				printf "%-20s %-10s %-s\n" "${toks[0]}" "${toks[1]}" "${dependecies}" 1>&2
			done < <(sort -k 1,1 -k 4,4 -k 5,5 "${tmpfile}" | awk "${with_modules}")
		else
			sort -k 1,1 -k 4,4 -k 5,5 "${tmpfile}" | awk "${with_modules}" 1>&2
		fi
	}
	#.....................................................................
	#
	# search modules
	# Args:
	#   $1: module name pattern
	#
	# Variables used from enclosing function
	#   :FIXME:
	#
	search () {
		local -r module=$1
		# write results to a temporary file for later processing
		local -r tmpfile=$( mktemp /tmp/$(basename $0).XXXXXX ) \
		    || std::die 1 "Oops: unable to create tmp file!"
		local _group
		# loop over all groups
		for _group in "${Groups[@]}"; do
			# loop over all directories which can be added to
			# MODULEPATH inside current group
			local depth=${GroupDepths[${_group}]}
			local mpaths=( $(find \
					     "${src_prefix}/${_group}/modulefiles" \
					     -type d \
					     -mindepth ${depth} -maxdepth ${depth} \
					     2>/dev/null))
			local mpath
			for mpath in "${mpaths[@]}"; do
				# get dependencies encoded in directory name
				local p="${mpath/${src_prefix}}"
				p=( ${p//\// } )
				local deps=()
				local -i i
				for ((i=2; i < ${#p[@]}; i+=2)); do
					deps+=( ${p[i]}/${p[i+1]} )
				done
				local requires=${deps[@]}

				# get and print all available modules in $mpath
				# with respect to the requested releases
				local mods=( $( get_available_modules \
						    "${mpath}" \
						    "${module}" \
						    "${opt_use_releases}" ) )
				[[ ${#mods[@]} == 0 ]] && continue
				for (( i=0; i<${#mods[@]}; i+=2 )); do
					printf "${fmt}" ${mods[i]} "${mods[i+1]}" \
					       ${_group} "${requires}" >> "${tmpfile}"
				done
			done
		done
		print_result "${tmpfile}"
		rm -f "${tmpfile}"
	}

	opts=$(pmodules::get_options -o 'ahH?' \
			   -l help \
			   -l no-header \
			   -l print-modulefiles \
			   -l release: \
			   -l with: \
			   -l all-releases \
			   -l src: \
			   -l print-variants \
			   --  "$@") || subcommand_help_${subcommand}
	eval set --  "${opts}"
	
	while (( $# > 0 )); do
		case $1 in
			--no-header )
				opt_print_header='no'
				;;
			--print-modulefiles )
				opt_print_modulefiles='yes'
				opt_print_header='no'
				;;
			--release )
				is_release "$2" || \
				    std::die 1 "${CMD} search: illegal release name -- $2"
				opt_use_releases+="$2:"
				shift
				;;
			--with )
				if [[ -z $2 ]] || [[ "$2" =~ "-*" ]]; then
				        std::die 1 "${CMD} search: with what?"
				fi
				with_modules+=" && / ${2//\//\\/}/"
				shift
				;;
			-a | --all-releases )
				opt_use_releases="${PMODULES_DEFINED_RELEASES}"
				;;
			--src )
				src_prefix=$2
				pmodules::check_directories "${src_prefix}"
				shift
				;;
			--print-variants )
				opt_print_variants='yes'
				opt_print_header='no'
				opt_use_releases="${PMODULES_DEFINED_RELEASES}"
				:
				;;
			-\? | -h | -H | --help )
				usage
				;;
			-- )
				;;
			* )
				modules+=( "$1" )
				;;
		esac
		shift
	done
	if [[ -z "${src_prefix}" ]]; then
	        src_prefix="${PMODULES_ROOT}"
	fi
	
	if [[ "${opt_use_releases}" == ":" ]]; then
                opt_use_releases=":${UsedReleases}:"
	fi
	
	if [[ ${#modules[@]} == 0 ]]; then
		modules+=( '' )
	fi

	if (( ${#Groups[@]} == 0 )) || [[ ${src_prefix} != ${PMODULES_ROOT} ]]; then
	        get_groups "${src_prefix}"
		get_group_depths "${src_prefix}"
	fi
	
	for module in "${modules[@]}"; do
		search "${module}"
	done
}

#
# help [module|sub-command]
#
subcommand_help() {
	local opts=''
	opts=$(pmodules::get_options -o HV\? -l version -l help -- "$@") || usage
	eval set --  "${opts}"
	local arg=''
	
	while (( $# > 0 )); do
		case $1 in
			-[hH] | -\? | --help )
				usage
				;;
			-V | --version )
				print_version
				std::die 1
				;;
			-- )
				:
				;;
			* )
				[[ -z ${arg} ]] || \
				    std::die 1 "${CMD} help: only one argument allowed."
				arg="$1"
				;;
		esac
		shift
	done
	if [[ -z ${arg} ]]; then
	        usage
	elif typeset -F subcommand_help_${arg} > /dev/null 2>&1 ; then
	        # help for sub-command
		subcommand_help_${arg}
	else
		# :FIXME: print help of newest *available* module
		# (respecting UsedReleases)
		subcommand_generic1plus help "${arg}"
	fi
}

#
# whatis [module]
#
subcommand_whatis() {
	if (( $# == 0 )); then
	        subcommand_generic0 whatis
	else
		subcommand_generic1plus whatis "$@"
	fi
}

#
# apropos string
#
subcommand_apropos() {
	subcommand_generic1 apropos "$@"
}

#
# initadd module...
#
subcommand_initadd() {
	subcommand_generic1plus initadd "$@"
}

#
# initprepend module...
#
subcommand_initprepend() {
	subcommand_generic1plus initprepend "$@"
}

#
# initrm module...
#
subcommand_initrm() {
	subcommand_generic1plus initrm "$@"
}

#
# initswitch module1 module2
#
subcommand_initswitch() {
	subcommand_generic1or2 initswitch "$@"
}

#
# initlist
#
subcommand_initlist() {
	subcommand_generic0 initlist "$@"
}

#
# initclear
#
subcommand_initclear() {
	subcommand_generic0 initclear "$@"
}

if [[ -n ${PMODULES_ENV} ]]; then
	eval "$("${PMODULES_HOME}/bin/base64" -d <<< "${PMODULES_ENV}" 2>/dev/null)"
else
	pmodules_init
fi

case $1 in
	bash )
		declare g_shell="$1"
		;;
	tcsh )
		declare g_shell="$1"
		;;
	* )
		std::die 1 "${CMD}: unsupported shell -- $1"
		;;
esac
shift

declare -a opts=()
while (( $# > 0 )); do
	case $1 in
		-H | -\? | --help | -help )
			usage
			;;
		-V | --version )
			print_version
			std::die 1
			;;
		--debug )
			set -x
			;;
		-* )
			opts+=( "$1" )
			;;
		add|load )
			subcommand='subcommand_load'
			shift
			opts+=( "$@" )
			shift $#
			;;
		rm|unload )
			subcommand='subcommand_unload'
			shift
			opts+=( "$@" )
			shift $#
			;;
		switch|swap )
			subcommand='subcommand_swap'
			shift
			opts+=( "$@" )
			shift $#
			;;
		display|show )
			subcommand='subcommand_show'
			shift
			opts+=( "$@" )
			shift $#
			;;
		apropos|keyword )
			subcommand='subcommand_apropos'
			shift
			opts+=( "$@" )
			shift $#
			;;
		avail|search|use|unuse|update|refresh|purge|list|clear|whatis|help )
			subcommand=subcommand_$1
			shift
			if (( $# > 0 )); then
			    opts+=( "$@" )
			    shift $#
			fi
			;;
		initadd|initprepend|initrm|initswitch|initlist|initclear )
			subcommand=subcommand_$1
			shift
			opts=( "$@" )
			shift $#
			;;
		* )
			std::die 1 "${CMD}: unknown sub-command -- $1"
			;;
	esac
	shift
done

if (( ${#Groups[@]} == 0 )); then
        get_groups "${PMODULES_ROOT}"
	get_group_depths "${PMODULES_ROOT}"
fi

$subcommand "${opts[@]}"

# Local Variables:
# mode: sh
# sh-basic-offset: 8
# tab-width: 8
# End:
